---
title: Normal Q-Q plots - what is the robust line and should we prefer it?
author: Jeff Walker
date: '2020-10-15'
slug: normal-q-q-plots-what-is-the-robust-line-and-should-we-prefer-it
categories:
  - stats 101
tags: []
keywords:
  - tech
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
# import an messaging
library(here)
library(janitor)
library(readxl)
library(data.table)

# analysis
library(car)
library(MASS) # rnegbin

# graphics and output
library(ggpubr) # qq plot functions
library(ggpubfigs) # palette
library(qqplotr) ## qq plot functions
library(ggforce)
library(cowplot)

here <- here::here
data_folder <- "content/data"

# Okabe & Ito palette
ito_seven <- friendly_pal("ito_seven") # ggpubfigs
pal_okabe_ito <- ito_seven[c(6,5,3,7,1,2,4)] # order of Wilke

```

Source: [Wellenstein, M.D., Coffelt, S.B., Duits, D.E., van Miltenburg, M.H., Slagter, M., de Rink, I., Henneman, L., Kas, S.M., Prekovic, S., Hau, C.S. and Vrijland, K., 2019. Loss of p53 triggers WNT-dependent systemic inflammation to drive breast cancer metastasis. Nature, 572(7770), pp.538-542.](https://www.nature.com/articles/s41586-019-1450-6){target="_blank"}

[Public source](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6707815/){target="_blank"}

[Data source](https://www.nature.com/articles/s41586-019-1450-6#Sec22){target="_blank"}

```{r echo=TRUE}
data_from <- "Loss of p53 triggers WNT-dependent systemic inflammation to drive breast cancer metastasis"
file_name <- "41586_2019_1450_MOESM3_ESM.xlsx"
file_path <- here(data_folder, data_from, file_name)
  
treatment_levels <- c("Trp53+/+", "Trp53-/-")
fig1f <- read_excel(file_path,
                     sheet = "Fig. 1f",
                     range = "A2:B23") %>%
  data.table() %>%
  melt(measure.vars = treatment_levels,
       variable.name = "treatment",
       value.name = "il1beta")
fig1f[, treatment := factor(treatment, treatment_levels)]

# be careful of the missing data. This can create mismatch between id and residual unless specified in lm

# head(fig1f)
```

## Fit a linear model

```{r}
m1 <- lm(il1beta ~ treatment, data = fig1f)

# residuals
m1_res <- residuals(m1)

# studentized residuals
sigma_m1_res <- sd(m1_res) # will use this again
m1_res_st <- m1_res/sigma_m1_res

n <- length(m1_res)
```

```{r, echo=FALSE, eval=FALSE}
# tl;dr qqPlot(x) defaults to quartile line while
# qqPlot(lm(x ~ 1)) defaults to robust

set.seed(20200825)
x_dt <- data.table(x = sort(rnorm(20, 10, 3)))
m1 <- lm(x ~ 1, data = x_dt)

# residuals
m1_res <- residuals(m1)

# studentized residuals
sigma_m1_res <- sd(m1_res) # will use this again
m1_res_st <- m1_res/sigma_m1_res

n <- length(m1_res)

q <- (rank(x) - .5) / length(x)

d <- data.table(
  x_sample = x, 
  quantile = ppoints(length(x)),
  x_theoretical = qnorm(q, mean(x), sd(x))
)

se_z <- function(z, n) {
  sqrt(pnorm(z) * (1 - pnorm(z)) / n) / dnorm(z)
}

  z = seq(-2.2, 2.2, length.out = 300)
  n = length(d$x_sample)
  
  robust_sd = IQR(d$x_sample) / 1.349
  robust_line = median(d$x_sample) + z * robust_sd
  robust_se =  robust_sd * se_z(z, n)
  robust_upper = robust_line + 2 * robust_se
  robust_lower = robust_line - 2 * robust_se

par(mar = c(4, 2, 1, 2))

# Use patchwork to capture the plots and combine them 
# into a side by side display.
library(patchwork)
car::qqPlot(x)
p1 <- wrap_elements(~ car::qqPlot(x))

p2 <- wrap_elements(~ {
  car::qqPlot(x, line = "robust")
  lines(z, robust_line, col = "red", lwd = 2)
  lines(z, robust_upper, col = "black", lwd = 2)
  lines(z, robust_lower, col = "black", lwd = 2)
})

p2
```

## Q-Q plots

### Base R
```{r echo=TRUE, eval=TRUE}
# base R plot
qqnorm(m1_res)
qqline(m1_res)
```

### ggpubr
```{r}
# ggpubr plot
ggqqplot(data = data.table(m1_res = m1_res),
         x = "m1_res")

```
### car qqPlot
```{r}
# car plot

qqPlot(m1, 
       line = "robust", # this is default
       simulate = FALSE,
       id = FALSE)

```

Q-Q plots generated by base R, `ggpubr::ggqqplot` and `car::qqPlot` are shown. The base R and `ggqqplot` functions generate the same line. `ggplot2::geom_qqline` also generates this line (not shown, but try it!). The default `qqPlot` line differs from these three. This default is `line = "robust"`. If this argument is changed to `line = "quartiles"`, the qqPlot line is the same as base R/ggqqplot. The difference between "robust" and base R/ggqqplot/"quartiles" is pretty easy to see with these data. Look at points 2-4 starting from the left. In the base R/ggqqplot, points 2 is slightly above the line, point 3 is slighty below the line, and point 4 is above the line. In the `qqPlot`, all three points are above the line. Even more striking is the confidence interval. In the ggqqplot, the upper seven (rightmost) points are well outside the interval -- we would conclude that a sample from a Normal distribution would be unlikely to generate this pattern of quantiles and we should consider modeling with glm or a transformation, etc. In the qqPlot, these seven points are within or just outside the interval -- we would conclude that the a sample from a Normal would result in something like these quantiles at a common enough frequency to not worry about modeling with a glm or transformation or whatever.

Two different interepretations, two different "decisions". Which should decision should we decide on? I'll return to that. But first, some sleuthing.

### What are "robust" and "quartiles" lines? Building a Q-Q plot manually

Being curious what the parameters of these lines are, I went to the source -- the help page for `qqPlot`. The text for the argument `line` is

> "quartiles" to pass a line through the quartile-pairs, or "robust" for a robust-regression line; the latter uses the rlm function in the MASS package. 

Okay so let's make three lines

1. parametric -- the regression line of the sample quantiles on the theoretical quantiles
2. quartiles -- the regression line through the sample quartiles (the quantiles at 25% and 75%). Not sure what the intercept is. A little exploration indicated this is the median sample quartile. this is obvious in hindsight given the slope is through the quartiles.
3. robust -- the regression line using `MASS::rlm`. This function has several arguments. I used the defaults.

In addition to these, I used a parametric bootstrap to create my own 95% confidence band of the sample quantiles. For this, I sampled $n$ points from a standard, Normal distribution and plotted the Q-Q of this sample. I repeated this 1000 times to generate the distributions of expected sample quantiles for at each of the $n$ theoretical quantile. The 95% CI was computed as the 2.5th and 97.5th percentiles of each of these distributions.

```{r}
normal_qq <- ppoints(n) %>%
  qnorm()
sample_qq <- m1_res[order(m1_res)]

# mean + sd
parametric_slope <- sd(sample_qq)
parametric_intercept <- mean(sample_qq)

# quartiles
m1_quartiles <- quantile(m1_res, c(.25, .75))
qnorm_quartiles <- qnorm( c(.25, .75))
m1_diff <- m1_quartiles[2] - m1_quartiles[1]
qnorm_diff <- qnorm_quartiles[2] - qnorm_quartiles[1] # = 1.349
quartile_slope <- m1_diff/qnorm_diff
quartile_intercept <- median(sample_qq)

# robust uses MASS:rlm (default arguments?)
qq_observed <- data.table(normal_qq = normal_qq,
                    sample_qq = sample_qq)
m2 <- rlm(sample_qq ~ normal_qq, data = qq_observed)
robust_intercept <- coef(m2)[1]
robust_slope <- coef(m2)[2]

# re-sample ribbon
n_iter <- 1000
resample_qq <- numeric(n_iter*n)
inc <- 1:n
for(iter in 1:n_iter){
  y <- rnorm(n, sd = sigma_m1_res)
  y_res <- y - mean(y)
  resample_qq[inc] <- y_res[order(y_res)]
  inc <- inc + n
}

qq_sim <- data.table(normal_qq = normal_qq,
                     resample_qq = resample_qq)

qq_ci <- qq_sim[, .(median = median(resample_qq),
                     lower = quantile(resample_qq, 0.025),
                     upper = quantile(resample_qq, 0.975)),
                 by = normal_qq]

ggplot(data = qq_observed,
       aes(x = normal_qq, y = sample_qq)) +
  
  # ribbon
  geom_ribbon(data = qq_ci,
              aes(ymin = lower,
                  ymax = upper,
                  y = median,
                  fill = "band"),
              fill = "gray",
              alpha = 0.6) +
  # draw points
  geom_point() +
  
  # ggplot's qq line
  geom_qq_line(aes(sample = sample_qq,
                   color = "geom_qq_line"),
               show.legend=TRUE,
               size = 0.75) +
  # parametric
  geom_abline(aes(intercept = parametric_intercept,
                  slope = parametric_slope,
                  color = "parametric"),
              show.legend=TRUE,
              size = 0.75) +
  # quartile
  geom_abline(aes(intercept = quartile_intercept,
                  slope = quartile_slope,
                  color = "quartile"),
              show.legend=TRUE,
              size = 0.75,
              linetype = "dashed") +
  # robust
  geom_abline(aes(intercept = robust_intercept,
                  slope = robust_slope,
                  color = "robust"),
              show.legend = TRUE,
              size = 0.75) +
  
  
  scale_color_manual(values = pal_okabe_ito[c(1:2,5:6)]) +
  theme_minimal_grid() +
  

  
  NULL

# geom_abline(aes(colour="best"),intercept=0, slope=1, show_guide=TRUE)+



```
Huh! The quartiles line, which is used by base R, ggpubr, and ggplot2, falls well outside the upper half of the 95% confidence band of sample quantiles sampled *from a normal distribution*. The parametric and robust lines slice more through the middle of the band, with the parametric nearly bisecting the band. This is a pretty good indicator that the `line = "robust"` option is preferable to the "quartiles" line used by base R/ggpubr/ggplot2.

## What's going on in Tristan Mahr's results?

In sleuthing out the parameters defining the lines in the different qqplot functions, in addition to the `qqPlot` help page, I discoverd Tristan Mahr's excellent blog post [Q-Q Plots and Worm Plots from Scratch](https://www.tjmahr.com/quantile-quantile-plots-from-scratch/){target="_blank"}.

What confused me about Tristan's results was the equivalence between the car::qqPlot line and a "robust" line that Tristan built by setting the robust slope to the interquartile interval divided by 1.349. This raised one minor and one major question.

Minor: where does the 1.349 come from? I discovered this somewhat accidentally by looking at the intermediate values in my computation. The 1.349 comes from the denominator of the slope computed by the theoretical quartiles

```{r}
qnorm_quartiles <- qnorm( c(.25, .75))
(qnorm_diff <- qnorm_quartiles[2] - qnorm_quartiles[1])
```
Major: Tristan's "robust" computation is my "quartiles" computation, which I got from the help page of `car::qqPlot`. This kinda makes sense. Tristan states

>Fox explains that this is a “robust” estimate for the line

and quotes from the author of qqPlot John Fox's book [Applied Regression Analysis and Generalized Linear Models](https://us.sagepub.com/en-us/nam/applied-regression-analysis-and-generalized-linear-models/book237254){target="_blank"}

> We can alternatively use the median as a robust estimator of [the mean] and the interquartile range / 1.349 as a robust estimator of [the standard deviation]. (The more conventional estimates [of the sample mean and SD] will not work well when the data are substantially non-normal.) [p. 39]

In my example, the qqPlot default is equivalent to my line computed using robust regression (`MASS::rlm`), which I got from the qqPlot help page. In Tristan's code, the qqPlot default is equivalent to his line computed using the sample quartiles. How could these both be TRUE? 

The answer took a bit more sleuthing. In my qqPlot code, I used the S3 method for class 'lm' and passed the fit linear model from `lm`. Tristan used the default s3 method and passed the vector of samples. Curiously, the default line in qqPlot differs between these, and this is in the help page.

Regardless, the line computed in Tristan's code is not the "robust" line but the "quartiles" line, despite Fox using the word "robust" in the explanation of the quartiles line.

## Simulation

I'll work on this tomorrow.

```{r}
# https://www.tjmahr.com/quantile-quantile-plots-from-scratch/
se_z <- function(z, n) {
  sqrt(pnorm(z) * (1 - pnorm(z)) / n) / dnorm(z)
}
```

```{r}
n_iter <- 1000
```

