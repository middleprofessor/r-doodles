---
title: Using Wright's rules and a DAG to compute the bias of an effect when we measure
  proxies for X and Y
author: Jeff Walker
date: '2020-02-07'
slug: using-wright-s-rules-and-a-dag-to-compute-the-bias-of-an-effect-when-we-measure-proxies-for-x-and-y
categories:
  - causal analysis
tags:
  - causal graph
  - fake data
  - Wright style path analysis
keywords:
  - tech
---

This is a skeletal post to work up an answer to a twitter question using Wright's rules of path models. Using this panel A from this figure

```{r}
fn <- "proxy_dag.jpg"
fig_path <- here::here("content/images")
knitr::include_graphics(fig_path)
```

the question is `I want to know about A->Y but I measure A* and Y*. So in figure A, is the bias the backdoor path from A* to Y* through A and Y?`

# If the data are standardized (everything as unit variance)
This is easy and just uses Wright's rules of adding up effects along a path

```{r}
n <- 10^6
b <- 0.6 # true effect
a1 <- 0.9 # standardized effect of A on A* -- this is the correlation of A with proxy
a2 <- 0.8 # standardized effect of Y o Y* -- this is the correlation of Y with proxy
A <- rnorm(n)
Y <- b*A + sqrt(1 - b^2)*rnorm(n)
astar <- a1*A + sqrt(1 - a1^2)*rnorm(n) # proxy for A
ystar <- a2*Y + sqrt(1 - a2^2)*rnorm(n) # proxy for Y
```

b is the true effect so a1*a2 is the bias. Note this isn't added to the true effect as in ommitted variable bias (confounding)

```{r}
a1*a2*b # expected measured effect
coef(lm(ystar ~ astar)) # measured effect
```

check some other measures

```{r}
var(A) # should be 1
var(Y) # should be 1
var(astar) # should be 1
var(ystar) # should be 1
cor(ystar, astar) # should be equal to expected measured effect


```

# if the data are not standardized

```{r}
n <- 10^5
rho_a1 <- 0.9 # correlation of A and A*
rho_a2 <- 0.8 # correlation of Y and Y*
rho_b <- 0.6 # standardized true effect of A on Y
sigma_A <- 2 # total variation in A
sigma_Y <- 10 # total variation in Y
sigma_astar <- 2.2 # total variation in A*
sigma_ystar <- 20 # total variation in Y* 
a1 <- rho_a1*sigma_astar/sigma_A # effect of A on astar
a2 <- rho_a2*sigma_ystar/sigma_Y # effect of Y on ystar
b <- rho_b*sigma_Y/sigma_A # effect of A on Y (the thing we want)
A <- rnorm(n, sd=sigma_A)
R2_Y <- (b*sigma_A)^2/sigma_Y^2
Y <- b*A + sqrt(1-R2_Y)*rnorm(n, sd=sigma_Y)
R2_astar <- (a1*sigma_A)^2/sigma_astar^2
astar <- a1*A + sqrt(1-R2_astar)*rnorm(n, sd=sigma_astar)
R2_ystar <- (a2*sigma_Y)^2/sigma_ystar^2
ystar <- a2*Y + sqrt(1-R2_ystar)*rnorm(n, sd=sigma_ystar)
```

1. first line returns the estimated effect of A on Y using the proxies
2. second is one way to return the expected estimated effect
3. third is another way to return the expected estimated effect. This is a function of the true effect so the long first part is the bias, which is `rho_a1*sigma_A/sigma_Y*rho_a2*sigma_ystar/sigma_astar`

Make either ratio in the bias >> 1 and the bias will magnify the estimate.

```{r}
coef(lm(ystar ~ astar))
rho_a1*rho_a2*rho_b*sigma_ystar/sigma_astar
rho_a1*sigma_A/sigma_Y*rho_a2*sigma_ystar/sigma_astar*b
b
```

Some other checks
```{r}
coef(lm(ystar ~ Y))
a2
```

```{r}
coef(lm(ystar ~ A))
a2*b
```

```{r}
coef(lm(astar ~ A))
a1
```


```{r}
sd(A)
sd(Y)
sd(astar)
sd(ystar)
cor(A, astar)
cor(Y, ystar)
```


```

