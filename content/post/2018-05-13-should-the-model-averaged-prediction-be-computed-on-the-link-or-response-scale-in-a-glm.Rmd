---
title: Should the model-averaged prediction be computed on the link or response scale
  in a GLM?
author: Jeff Walker
date: '2018-05-13'
slug: should-the-model-averaged-prediction-be-computed-on-the-link-or-response-scale-in-a-glm
categories: []
tags:
  - ecology
  - model-averaged predictions
  - model averaging
  - generalized linear models
---

(TL;DR: This post-includes a disagreement on the output of the R package MuMIn, which computes model-averaged predictions and coefficients. But I don't get to this until point 6 below.)

This post is a follow up [to my inital post](/04/04/model-averaged-coefficients-of-a-glm), which was written as as a way for me to pen my mental thoughts on the recent review of ["Model averaging in ecology: a review of Bayesian, information‐theoretic and tactical approaches for predictive inference"](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1002/ecm.1309){target="_blank"}. It was also written without contacting and discussing the issue with the authors. This post benefits from a series of e-mails with the lead author Carsten Dormann and the last author Florian Hartig.

The Dormann et al. paper focuses on model-averaged predictions, but has a short discussion on problems with model-averaged coefficients in the supplement. It is in the supplement, that the authors state that for generalized linear models (GLMs) "coefficient averaging is not equivalent to prediction averaging". Brian Cade^[Cade, B.S. (2015). Model averaging and muddled multimodel inferences. Ecology 96, 2370–2382.
] also makes this argument.

In my previous post, I argued that this statement is wrong -- predictions from a parameter-averaged model is mathematically identical to averaging predictions. It was hard for me to understand how this was not immediately obvious until my e-mail exchange with Carsten and Florian. In short, I assume that all averaging is done on the link scale and then the predictions are back-transformed to the response scale. Carsten and Florian (and Brian Cade?) argue that this is the "wrong" way to compute averaged predictions.

The summary of our differences is

1. Carsten and Florian argue that predictions should computed on the link scale, back-transformed to the response scale, and then averaged on the response scale. I understand their reason to be that first, this is how everyone outside of ecology does it, and second, predictions have to be averaged on the response scale for non-linear models because there is no link scale, and, since, GLMs are non-linear models, they should be averaged on the response scale.

2. I argue that because a GLM model is fit on a linear scale, any subsequent averaging should be on the linear scale. My reason is that because a GLM *is a linear model*, additive math should be additive (on the link scale) and not multiplicative (on the response scale) to be consistent with the meaning of the fit parameters. For example, a prediction is a weighted sum of the data, with weights that are a function of a linear fit, and everyone agrees that predictions should be computed on the link scale and then back-transformed (if desired). And, a model-averaged prediction is a weighted sum, with both weights and variables that are functions of linear fits, and so the predictions should be averaged on the link scale, and then back-transformed to the response scale (if desired).

Some final thoughts using their equation S2

\begin{equation}
\frac{1}{m} \sum_{i=1}^m{g^{-1}(Xb_i)} \ne g^{-1}(X \frac{\sum_{i=1}^m{b_i}}{m})
\end{equation}

3. Dormann et al. advocate averaging using the LHS of eq. S2, I advocate using the RHS.

4. If using the RHS of S2 to average predictors, [then averaging the predictors or computing the predictor from averaged coefficients are mathematically equivalent](/04/04/model-averaged-coefficients-of-a-glm).

5. GLMs are unlike non-linear models in that non-linear models do not have link functions although some can be linearized. There is no linear model that is fit. Consquently, for non-linear models, averging the predictors of non-linear models on the "response scale" is consistent with the fit model. So in my opinion, this isn't good justification for averaging GLMs on the response scale.

6. Because Carsten and Florian (and presumably the other co-authors of Dormann et al.) argue that predictions should be model averaged on the response scale, they argue that predict.averaging () from the MuMIn package is the wrong way to compute averaged predictors, since these are computed on the link scale and then back-transformed to the response scale. I argue that this is the "right" way to compute these, where "right" is in the sense that it maintains the meaning of the parameters.

7. I think this argument from Russell Lenth, the author of the amazingly useful emmeans (formerly lsmeans) package, supports my argument for averaging on the link scale. Here, Lenth comments on why [the package computes marginal means on the link and not response scale for GLMs](https://cran.r-project.org/web/packages/emmeans/vignettes/transformations.html):

> The model is our best guide

> This choice of timing is based on the idea that the model is right. In particular, the fact that the response is transformed suggests that the transformed scale is the best scale to be working with. In addition, the model specifies that the effects of source and percent are linear on the transformed scale; inasmuch as marginal averaging to obtain EMMs is a linear operation, that averaging is best done on the transformed scale. For those two good reasons, back-transforming to the response scale is delayed until the very end by default."

8. The difference in predicted values computed on the link vs. response scale is trivially small for the example below, and perhaps in most real examples, and if this is the case, our argument doesn't really matter. There are much bigger sources of error in modeling than this.

9. Finally, in response to an exchange with Florian, I wanted to make sure that my understanding of MuMIn is correct (it seems to be), so here are five ways to compute a simple count (poisson) example using fake data in addition to the computation from MuMIn.

```{r libraries}
library(ggplot2)
library(MuMIn)
library(BAS)
library(data.table)
```

A simple model of counts

```{r fakedata}
  set.seed(1)
  n <- 100
  exp_beta_0 <- 175 # mean Y on response scale
  exp_beta_1 <- 0.99 # effect on response scale
  exp_beta_2 <- 0.99 # effect on response sacle
  
  # create correlated x1 and x2 due to common factor z
  z <- rnorm(n) # common factor to correlate X1 and X2
  r <- 0.6 # correlation between x1 and x2
  alpha <- sqrt(r) # "effect" of Z on X1 and X2
  x1 <- alpha*z + sqrt(1-r)*rnorm(n)
  x2 <- alpha*z + sqrt(1-r)*rnorm(n)

  # expected count in link space
  E_log_count <- log(exp_beta_0) + log(exp_beta_1)*x1 + log(exp_beta_2)*x2 # expected log count
  # observed counts
  count <- rpois(n=n, lambda=exp(E_log_count))

  # create data.table and fit 
  dt <- data.table(count=count, x1=x1, x2=x2)
  fit <- glm(count ~ x1 + x2, family=poisson(link = "log"), data=dt,na.action=na.fail )
  X <- model.matrix(fit)
  
  # all model regression using MuMIn
  fit.mm <- dredge(fit)
  model_set <- get.models(fit.mm, subset=TRUE) # all models
  fit.avg <- model.avg(model_set) # coeffcients are on link scale
  fit.avg
  
  # (0) MuMIn predict
  yhat0.MuMIn <- predict(fit.avg, backtransform=TRUE)
  
  #is this averaged on link or response scale? And is it the coefficients or the prediction that is averaged?
  
  # (1) average coefficients on link scale. compute prediction on link scale. transform predictions to response scale
  b <- fit.avg$coefficients['full',][colnames(X)]
  yhat1 <- exp((X%*%b)[,1]) #
  b_ma_link <- b

  # (2) compute predictions for each model on link scale. Average on link scale. Backtransform to response scale
  yhat2a <- exp(predict(fit.avg, backtransform=FALSE))
  w <- fit.mm$weight
  yhat2b.each_model.link_scale <- sapply(model_set, predict)
  yhat2b.link_scale <- (yhat2b.each_model.link_scale%*%w)[,1]
  yhat2b <- exp(yhat2b.link_scale)
  
  # (3) compute predictions for each model on link scale. Backtransform to response scale. Average on response scale. This is method of Dormann et al.
  yhat3.each_model.response_scale <- exp(yhat2b.each_model.link_scale)
  yhat3 <- (yhat3.each_model.response_scale%*%w)[,1]
  
  # (4) backtransform coefficients to response scale. Average coefficients on response scale. Compute prediction on response scale.
  B <- exp(fit.mm[,colnames(X)])
  B[is.na(B)] <- 0.0
  b_ma <- t(B)%*%w
  yhat4 <- (X%*%b_ma)[,1] #

  # (5) average coefficients on link scale. backtransform to response scale. compute prediction on response scale
  b <- exp(fit.avg$coefficients['full',][colnames(X)])
  yhat5 <- (X%*%b)[,1] #

```

# Results
The first few rows of the results matrix of the predictions using five different methods for their computation.

```{r table, echo=FALSE}
  
res <- data.table(MuMIn=yhat0.MuMIn,
                  yhat1=yhat1, 
                  yhat2=yhat2b, 
                  yhat3=yhat3,
                  yhat4=yhat4,
                  yhat5=yhat5)
  
head(res)
```

**Column Keys**

MuMIn = MuMIn's default prediction

yhat1 = Coefficients averaged on link scale. Predictions computed on link scale from averaged coefficients and then backtransformed to response scale. My preferred method. RHS of eq. S2.

yhat2 = Predictions computed on link scale for each model and then averaged on link scale and then backtransformed to response scale. Alternative to my preferred method.

yhat3 = Predictions computed on link scale for each model and then  backtransformed to response scale and then averaged on response scale. This is the method of Dormann et al. 2018 and Cade 2015

yhat4 = Coefficients backtransformed to response scale and then averaged on response scale. Predictions computed on response scale from averaged coefficients.

yhat5 = Coefficients averaged on link scale and then backtransformed to response scale, which are used to compute averaged predictions.



```{r bma, echo=FALSE, results='hide'}
  
  # fit using BMA
  packageVersion("BAS")
  # fit <- glm(count ~ x1 + x2, family=poisson(link = "log"), data=dt,na.action=na.fail )
  fit.bma <- bas.glm(count ~ x1 + x2, family=poisson(link = "log"), data=dt)
 
  res.bma.rs <- predict(fit.bma, type='response')
  res.bma0.rs <- res.bma.rs$fit[,1]
  res.bma1.rs.ls <- res.bma.rs$Ybma[,1]
  res.bma1.rs.exp.ls <- exp(res.bma1.rs.ls)
  
  res.bma.ls <- predict(fit.bma)
  res.bma0.ls <- res.bma.ls$fit[,1]
  res.bma1.ls.ls <- res.bma.ls$Ybma[,1]
  res.bma1.ls.exp.ls <- exp(res.bma1.ls.ls)
  
  head(data.table(
    res.bma0.rs, res.bma1.rs.ls, res.bma1.rs.exp.ls,
    res.bma0.ls, res.bma1.ls.ls, res.bma1.ls.exp.ls
  ))
  

  res.bma <- predict(fit.bma)
  yhat.bma.response <- res.bma$fit[,1]
  yhat.bma.link <- res.bma$Ybma[,1]
  YHAT <- t(res.bma$Ypred)
  w <- res.bma$postprobs
  # averaged on response scale
  yhat1.bma.response <- (exp(YHAT)%*%w)[,1]
  # averaged on link scale and then backtransformed
  yhat2.bma.link <- (YHAT%*%w)[,1]
  yhat2.bma.response <- exp(yhat2.bma.link)

  head(data.table(yhat0=yhat.bma.response,
             yhat1=yhat1.bma.response,
             yhat2=yhat2.bma.response))

```

