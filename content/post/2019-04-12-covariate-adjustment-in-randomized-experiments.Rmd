---
title: Covariate adjustment in randomized experiments
author: Jeff Walker
date: '2019-04-12'
slug: covariate-adjustment-in-randomized-experiments
categories:
  - stats 101
tags:
  - ancova
  - categorical X
---

[The post motivated by a tweetorial from Darren Dahly](https://twitter.com/statsepi/status/1115902270888128514)

In an experiment, do we adjust for covariates that differ between treatment levels measured pre-experiment ("imbalance" in random assignment), where a difference is inferred from a t-test with p < 0.05? Or do we adjust for all covariates, regardless of differences pre-test? Or do we adjust only for covariates that have sustantial correlation with the outcome? Or do we not adjust at all?

Here I look at the effect of the adjustment on the measure of precision (the standard error of the estimate of the treatment effect)


```{r libraries, message=FALSE}
library(ggplot2)
library(GGally)
library(data.table)

source("../R/fake_x.R") # bookdown

```

# Fake data

Generate 11 correlated variables and assign the first to the response ($\mathbf{y}$) and the rest to the covariates ($\mathbf{X}$). Construct a treatment variable and effect and add this to the response.

```{r}

n <- 100 # per treatment level - this is modified below
p <- 10 # number of covariates (columns of the data)
pp1 <- p+1
beta_0 <- 0 # intercept
beta_1 <- 0.8 # treatment effect on standardized scale
beta <- c(beta_0, beta_1)
target_cor <- 0.3

niter <- 1000
b <- se <- pval <- matrix(NA, nrow=niter, ncol=3)
colnames(b) <- colnames(se) <- colnames(pval) <- c("no_adjust", "imbalance", "covariate")

xcols <- paste0("X", 1:p)
build_ycols <- c("Y_o", xcols)
cor_ycols <- c("Y", xcols)

b_mat <- data.table(NULL)
se_mat <- data.table(NULL)
p_mat <- data.table(NULL)

for(n in c(20, 40, 100, 1000)){
  Treatment <- rep(c("Cn", "Tr"), each=n)
  X <- model.matrix(formula("~ Treatment"))
  for(target_cor in c(0, .2, .5)){
    for(iter in 1:niter){
      # generate p random, correlated variables. The first is assigned to Y
      fake_data <- fake.X(n*2, pp1, fake.eigenvectors(pp1), fake.eigenvalues(pp1))
      colnames(fake_data) <- build_ycols
      
      # resacale so that var(Y) = 1, where Y is the first column
      fake_data <- fake_data/sd(fake_data[,1])
      
      fake_data <- data.table(fake_data)
      
      # view the scatterplots
      #gg <- ggpairs(X,progress = ggmatrix_progress(clear = FALSE))
      show_it <- FALSE
      if(show_it ==TRUE){
        gg <- ggpairs(fake_data)
        print(gg, progress = F)
      }
      
      # add the treatment effect
      fake_data[, Y:=Y_o + X%*%beta]
      fake_data[, Treatment:=Treatment]
      
      fit1 <- lm(Y ~ Treatment, data=fake_data)

      res <- coef(summary(fit1))["TreatmentTr", ]
      b[iter, 1] <- res["Estimate"]
      se[iter, 1] <- res["Std. Error"]
      pval[iter, 1] <-res["Pr(>|t|)"]
      
      # adjust for imablance
      inc_xcols <- NULL
      for(i in 1:p){
        formula <- paste0(xcols[i], " ~ Treatment")
        fit2a <- lm(formula, data=fake_data)
        if(coef(summary(fit2a))["TreatmentTr", "Pr(>|t|)"] < 0.05){
          inc_xcols <- c(inc_xcols, xcols[i])
        }
      }
      if(length(inc_xcols) > 0){
        formula <- paste0("Y ~ Treatment + ", paste(inc_xcols, collapse=" + "))
        fit2b <- lm(formula, data=fake_data)
        res <- coef(summary(fit2b))["TreatmentTr", ]
        b[iter, 2] <- res["Estimate"]
        se[iter, 2] <- res["Std. Error"]
        pval[iter, 2] <-res["Pr(>|t|)"]
      }

      # adjust for covariates
      (ycor <- abs(cor(fake_data[, .SD, .SDcols=cor_ycols])[2:pp1, 1]))
      mean(ycor)
      
      inc <- which(ycor > target_cor)
      if(length(inc) > 0){
        inc_xcols <- xcols[inc]
        formula <- paste0("Y ~ Treatment + ", paste(inc_xcols, collapse=" + "))
        fit3 <- lm(formula, data=fake_data)
        res <- coef(summary(fit3))["TreatmentTr", ]
        b[iter, 3] <- res["Estimate"]
        se[iter, 3] <- res["Std. Error"]
        pval[iter, 3] <-res["Pr(>|t|)"]
      }
      
    }
    b_mat <- rbind(b_mat, data.table(n=n, min_r=target_cor, b))
    se_mat <- rbind(se_mat, data.table(n=n, min_r=target_cor, se))
    p_mat <- rbind(p_mat, data.table(n=n, min_r=target_cor, p))
  }  
}


pd <- position_dodge(1)
se_long <- melt(se_mat, measure.vars=c("no_adjust", "imbalance", "covariate"), variable.name="method", value.name="se")
gg <- ggplot(data=se_long, aes(x=factor(min_r), y=se, fill=method)) +
  geom_boxplot(position=pd) +
  facet_grid(.~factor(n)) +
  xlab("minimum COR(Y, X) to add as covariate") +
  NULL
gg

```


